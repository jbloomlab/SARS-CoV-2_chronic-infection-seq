#!/usr/bin/env python

""" 
ParsePileup.py: This program takes a pileup format file
from samtools and parses to user specificiation.

python workflow/scripts/ParsePileup.py --input {input} --output {output} -si
"""

__author__      = "William Hannon"
__copyright__   = "Copyright 2020, William Hannon"

## ==== Imports ==== ##

from collections import Counter
import argparse
import time

## ==== Functions ==== ##

def ASCII2Phred(ASCII):
    """ 
    Convert ASCII character to integer Phred quality.
    """
    return ord(str(ASCII)) - 33

def Main():
    """
    Main function to run program.
    """

    # Set up the argsparse arguments
    my_parser = argparse.ArgumentParser()

    # Argument for input filepath
    my_parser.add_argument('--input', action='store', type=str, required=True,
                            help="File path to mpileup file generated by samtools.")
    # Argurment for output filepath
    my_parser.add_argument('--output', action='store', type=str, required=True,
                            help="File path to desired output file.")
    # Boolean for calling all bases. 
    my_parser.add_argument("-a", "--all", action='store_true',
                            help="Count all bases at each position.")
    # Boolean for calling SNPs
    my_parser.add_argument("-s", "--snps", action='store_true',
                            help="Call SNPs and allele frequencies.")
    # Boolean for calling indels
    my_parser.add_argument("-i", "--indels", action='store_true',
                            help="Call InDels and allele frequencies.")

    # Parse the command line arguments
    args = my_parser.parse_args()

    # Open the file and output file
    # Open the pileup file stream
    with open(args.input) as mpileup:
        
        # Open an output file stream
        with open(args.output, "w") as output:

            if args.all:
                # Save the header 
                output.write("POS,REF,DP,A_fwd,A_rev,T_fwd,T_rev,C_fwd,C_rev,G_fwd,G_rev\n")

            if args.snps or args.indels:
                # Save the header 
                output.write("POS,DP,REF,ALT,AF,COUNT\n")

            # Iterate over each line in the pileup file
            for line in mpileup:
                
                # Retrieve each element of the record. 
                record = line.strip("\n").split("\t")
                
                # Make the pileup object
                pileup = Pileup(record)
                
                # All bases
                if args.all:
                    # Save the line 
                    output.write(pileup.call_all_bases())

                if args.snps:
                    # Save the line if not None
                    if pileup.call_polymorphisms():
                        output.write(pileup.call_polymorphisms())

                if args.indels:
                    # Save the line if not None
                    if pileup.call_indels():
                        output.write(pileup.call_indels())

## ==== Classes ==== ##

class Pileup:
    """
    Class to hold the information in a single line of a 
    pileup file from samtools mpileup. Requires a record
    as a list to instantiate an instance. 
    """
    
    def __init__(self, record):
        """
        Instantiate instance properties.
        """
        
        # Save the record 
        self.record = record
        
        ## === Get info from record === ##
            
        # Chromosome name
        self.chromosome = self.record[0]

        # 1-index position in genome
        self.position = int(self.record[1])

        # Reference base
        self.reference = self.record[2]

        # Read depth over postion
        self.depth = int(self.record[3])
        
        # Read characters (. , * # + - ATGCNatgcn)
        self.ReadBases = self.record[4]
        
        # Base quality ASCII characters 
        self.BAQ = [ASCII2Phred(qual) for qual in self.record[5] if self.depth != 0]
    
        # Base positions in reads
        self.ReadPositions = [int(pos) for pos in self.record[6].split(',') if self.depth != 0]
        
        # Read quality ASCII characters
        self.MAPQ = [ASCII2Phred(qual) for qual in self.record[7] if self.depth != 0]
        
    def __repr__(self):
        """
        Method to print record.
        """
        
        return f'Pileup({self.record})'
    
    def __parse_read_bases(self):
        """
        Method to parse ReadBases from self.ReadBases
        """
        
        # List to hold the translated bases
        self.bases = []
        
        # List to hold the types
        self.types = []
        
        # List to hold the strand
        self.strand = []
        
        # Return an empty list if there are no reads
        if self.depth == 0:
            
            pass
        
        else: 
            
            # Set the index to 0
            index = 0
            
            # Traverse the string of ReadBases
            while index < len(self.ReadBases):
                
                # Get the character at this position
                char = self.ReadBases[index]
                
                ## === Check if this is the reference base === ##
                
                # This represents a reference base on the forward strand
                if self.ReadBases[index] == ".":
                    
                    # Check that it isn't the end of the string
                    if index != len(self.ReadBases) - 1:

                        # This represents an insertion
                        if self.ReadBases[index + 1] == "+":
                            # Get the length of the insertion
                            insertion_length = int(self.ReadBases[index + 2])
                            # Get the sequence of the insertion
                            insertion_sequence = self.reference + self.ReadBases[index + 3 : index + 3 + insertion_length]
                            # Record the InDel 
                            self.bases.append(insertion_sequence)
                            # Record the type
                            self.types.append("insertion")
                            # Increment the index 
                            index += insertion_length + 3 

                        # This represents a deletion
                        elif self.ReadBases[index + 1] == "-":
                            # Get the length of the deletion
                            deletion_length = int(self.ReadBases[index + 2])
                            # Get the sequence of the deletion
                            deletion_sequence = self.reference + self.ReadBases[index + 3 : index + 3 + deletion_length]
                            # Record the InDel 
                            self.bases.append(deletion_sequence)
                            # Record the type
                            self.types.append("deletion")
                            # Increment the index 
                            index += deletion_length + 3
                            
                        # This represents a reference on forward strand
                        else:
                            # Save this base
                            self.bases.append(self.reference)
                            # Record the type
                            self.types.append("reference")
                            # Increment the index
                            index += 1

                    # This represents a reference on forward strand
                    else:
                        # Save this base
                        self.bases.append(self.reference)
                        # Record the type
                        self.types.append("reference")
                        # Increment the index
                        index += 1

                # This represents a reference base on the reverse strand 
                elif self.ReadBases[index] == ",":
                    
                    # Check that it isn't the end of the string
                    if index != len(self.ReadBases) - 1:

                        # This represents an insertion
                        if self.ReadBases[index + 1] == "+":
                            # Get the length of the insertion
                            insertion_length = int(self.ReadBases[index + 2])
                            # Get the sequence of the insertion
                            insertion_sequence = self.reference.lower() + self.ReadBases[index + 3 : index + 3 + insertion_length]
                            # Record the InDel 
                            self.bases.append(insertion_sequence)
                            # Record the type
                            self.types.append("insertion")
                            # Increment the index 
                            index += insertion_length + 3 

                        # This represents a deletion
                        elif self.ReadBases[index + 1] == "-":
                            # Get the length of the deletion
                            deletion_length = int(self.ReadBases[index + 2])
                            # Get the sequence of the deletion
                            deletion_sequence = self.reference.lower() + self.ReadBases[index + 3 : index + 3 + deletion_length]
                            # Record the InDel 
                            self.bases.append(deletion_sequence)
                            # Record the type
                            self.types.append("deletion")
                            # Increment the index 
                            index += deletion_length + 3
                            
                       # This represents a reference on forward strand
                        else:
                            # Save this base
                            self.bases.append(self.reference.lower())
                            # Record the type
                            self.types.append("reference")
                            # Increment the index
                            index += 1
                        
                    # This represents a reference on forward strand
                    else:
                        # Save this base
                        self.bases.append(self.reference.lower())
                        # Record the type
                        self.types.append("reference")
                        # Increment the index
                        index += 1
                        
                ## === Check if this is a placeholder === ##

                # This represents a placeholder on the forward strand (deletion)
                elif self.ReadBases[index] == "*":
                    # Save this placeholder
                    self.bases.append("P")
                    # Record the type
                    self.types.append("placeholder")
                    # Increment the index 
                    index += 1

                # This represents a placeholder on the reverse strand (deletion)
                elif self.ReadBases[index] == "#":
                    # Save this placeholder
                    self.bases.append("p")
                    # Record the type
                    self.types.append("placeholder")
                    # Increment the index
                    index += 1

                ## === Check if this is the start of a read === ##
                        
                # This represents the start of a read 
                elif self.ReadBases[index] == "^":
                    # Increment the index by two
                    index += 2 

                # This represents the end of a read
                elif self.ReadBases[index] == "$":
                    # Increment the index 
                    index += 1
                    
                ## === Check if this is a SNP === ##
                
                # Anything else represents a SNP
                else:
                    # Save this placeholder
                    self.bases.append(char)
                    # Record the type
                    self.types.append("polymorphism")
                    # Increment the index
                    index += 1
                    
                ## === Record the strand === ##
                
                self.strand = ["+" if base.isupper() else "-" for base in self.bases]
                
    def call_all_bases(self):
        """
        Method prints a line for all bases at each position. 
        """
        
        # Parse read bases
        self.__parse_read_bases()
        
        # Dict to save the occurence of bases
        base_count = {b:0 for b in 'ACTGNacgtn'}
        
        # Count the occurences of each base
        counts = Counter([b[0] for b in self.bases])
        
        # Update the occurences
        for base in base_count.keys():
            
            if base in counts.keys():
            
                base_count[base] = counts[base]
                
            else:
                
                base_count[base] = 0 
                 
        return (f"{self.position},{self.reference},{self.depth}"
                f",{base_count['A']},{base_count['a']}"
                f",{base_count['T']},{base_count['t']}"
                f",{base_count['C']},{base_count['c']}"
                f",{base_count['G']},{base_count['g']}\n")

    def call_polymorphisms(self):
        """
        Method returns a line per SNP. 
        """
        
        # Parse read bases
        self.__parse_read_bases()
        # Check if there are SNPs present in the record
        if "polymorphism" in self.types:
            # Save the identity of all SNPs
            snps = Counter([self.bases[i].upper() for i, t in enumerate(self.types) if t == "polymorphism"])
            # Record the total depth on the '+' and '-' strand.
            total_depth = Counter([self.strand[i] for i, t in enumerate(self.types) if t != "placeholder"])
            # Add the '+' or '-' strand information if one is missing.
            if '+' not in total_depth:
                total_depth['+'] = 0
            elif '-' not in total_depth:
                total_depth['-'] = 0
            # In case there are more than one SNP, iterate over all.
            for snp in snps.keys():
                # Get the SNP specific depth on the '+' and '-' strands. 
                snps_depth = Counter([self.strand[i] for i, b in enumerate(self.bases) if b.upper() == snp])
                # Add the '+' or '-' strand information if one is missing.
                if '+' not in snps_depth:
                    snps_depth['+'] = 0
                elif '-' not in snps_depth:
                    snps_depth['-'] = 0
                # Save the allele frequency
                af =  sum(snps_depth.values()) / sum(total_depth.values())
                # Save the individual counts on '+', '-', for total and SNP depth. 
                counts = f"{snps_depth['+']}/{snps_depth['-']}/{total_depth['+']}/{total_depth['-']}"
                # Return the formatted string line. 
                return (f"{self.position},{self.depth},{self.reference}"
                        f",{snp},{af},{counts}\n")
        
    def call_indels(self):
        """
        Method returns a line for all InDels. 
        """    
        # Parse read bases
        self.__parse_read_bases()
        # Check if there are any InDels in the record.
        if "insertion" or "deletion" in self.types:
            # Save all records of insertions (saved seperatley because order of REF/ALT matters)
            inserts = Counter([self.bases[i].upper() for i, t in enumerate(self.types) if t == "insertion"])
            # Save all records of deletions (saved seperatley because order of REF/ALT matters)
            dels = Counter([self.bases[i].upper() for i, t in enumerate(self.types) if t == "deletion"])
            # Save the total depth. 
            total_depth = Counter([self.strand[i] for i, t in enumerate(self.types) if t != "placeholder"])
            # Fill in the strand information if missing. 
            if '+' not in total_depth:
                total_depth['+'] = 0
            elif '-' not in total_depth:
                total_depth['-'] = 0
            # Iterate over all insertions 
            for insert in inserts.keys():
                # Get the depth per strand
                insert_depth = Counter([self.strand[i] for i, b in enumerate(self.bases) if b.upper() == insert])
                # Fill in missing information
                if '+' not in insert_depth:
                    insert_depth['+'] = 0
                elif '-' not in insert_depth:
                    insert_depth['-'] = 0
                # Get the allele frequency
                insert_af =  sum(insert_depth.values()) / sum(total_depth.values())
                # Record the counts
                insert_counts = f"{insert_depth['+']}/{insert_depth['-']}/{total_depth['+']}/{total_depth['-']}"
                # Return the formatted line
                return (f"{self.position},{self.depth},{self.reference}"
                        f",{insert},{insert_af},{insert_counts}\n")
            # Iterate over all deletions
            for delx in dels.keys():
                # Save the allele specific depth
                delx_depth = Counter([self.strand[i] for i, b in enumerate(self.bases) if b.upper() == delx])
                # Fill in the missing information for strands
                if '+' not in delx_depth:
                    delx_depth['+'] = 0
                elif '-' not in delx_depth:
                    delx_depth['-'] = 0
                # Save the allele frequency
                delx_af =  sum(delx_depth.values()) / sum(total_depth.values())
                # Save the strand specific counts
                delx_counts = f"{delx_depth['+']}/{delx_depth['-']}/{total_depth['+']}/{total_depth['-']}"
                # Return the formatted line
                return (f"{self.position},{self.depth},{delx}"
                        f",{self.reference},{delx_af},{delx_counts}\n")

## ==== Run ==== ##

if __name__ == "__main__":
    start = time.time()
    Main()
    end = time.time()
    print(f'Finished in {(end-start)/60:.2f} minutes.')